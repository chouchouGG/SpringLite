# 为什么基于CGlib实现的代理可以赋值给原类型，而基于JDK实现的代理不能复制给原类型？

## JDK 动态代理

实现原理:

- JDK 动态代理使用 java.lang.reflect.Proxy 类和 java.lang.reflect.InvocationHandler 接口来生成代理对象。这个代理对象是一个在运行时动态生成的实现了指定接口的类。

特点:
1. 接口代理：JDK 动态代理只能代理实现了接口的类。
2. 类型限制：由于代理类实现了目标接口，因此代理对象的类型只能赋值给该接口类型，而不能赋值给目标类类型。

## CGLIB 动态代理

实现原理:

- CGLIB（Code Generation Library）使用字节码生成技术创建目标类的子类，重写方法以实现代理逻辑。

特点:
1. 类代理：CGLIB 代理可以代理没有实现接口的类，因为它是通过生成目标类的子类来实现代理的。
2. 类型兼容：由于 CGLIB 生成的代理类是目标类的子类，因此代理对象可以赋值给目标类类型。

## 总结
1. **JDK 动态代理**：生成的代理类实现了目标接口，因此代理对象只能赋值给接口类型，而不能赋值给目标类类型。
2. **CGLIB 动态代理**：生成的代理类是目标类的子类，因此代理对象可以赋值给目标类类型。

这种区别源自于两种代理机制的实现原理。JDK 动态代理依赖于接口实现，适用于基于接口的编程模式，而 CGLIB 动态代理通过子类继承，适用于需要代理没有接口的类的情况。在实际应用中，可以根据具体需求选择合适的代理机制。